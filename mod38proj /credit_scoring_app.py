import streamlit as st
import pandas as pd
import numpy as np
import pickle
import time
from datetime import datetime
import io
import plotly.express as px
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.base import BaseEstimator, TransformerMixin

# ============================================================================
# CONFIGURA√á√ÉO DA APLICA√á√ÉO
# ============================================================================

st.set_page_config(
    page_title="Sistema de Escoragem de Cr√©dito",
    page_icon="üí≥",
    layout="wide"
)

# ============================================================================
# CLASSES E FUN√á√ïES AUXILIARES
# ============================================================================

class OutlierRemover(BaseEstimator, TransformerMixin):
    """Remove outliers usando IQR ou Z-score"""
    def __init__(self, method='iqr', factor=1.5):
        self.method = method
        self.factor = factor
        self.bounds_ = {}
    
    def fit(self, X, y=None):
        if isinstance(X, pd.DataFrame):
            numeric_cols = X.select_dtypes(include=[np.number]).columns
            for col in numeric_cols:
                if self.method == 'iqr':
                    Q1 = X[col].quantile(0.25)
                    Q3 = X[col].quantile(0.75)
                    IQR = Q3 - Q1
                    lower_bound = Q1 - self.factor * IQR
                    upper_bound = Q3 + self.factor * IQR
                    self.bounds_[col] = (lower_bound, upper_bound)
        return self
    
    def transform(self, X):
        X_transformed = X.copy()
        if isinstance(X_transformed, pd.DataFrame):
            for col, (lower, upper) in self.bounds_.items():
                if col in X_transformed.columns:
                    median_val = X_transformed[col].median()
                    X_transformed.loc[X_transformed[col] < lower, col] = median_val
                    X_transformed.loc[X_transformed[col] > upper, col] = median_val
        return X_transformed

@st.cache_data
def load_model(model_path):
    """Carrega o modelo treinado"""
    try:
        with open(model_path, 'rb') as file:
            model = pickle.load(file)
        return model, True
    except Exception as e:
        return str(e), False

def diagnose_model(model):
    """Analisa o modelo para descobrir o formato esperado dos dados"""
    diagnosis = {}
    
    try:
        preprocessor = model.named_steps['preprocessor']
        
        if hasattr(preprocessor, 'transformers_'):
            for name, transformer, columns in preprocessor.transformers_:
                if name == 'cat':
                    onehot_encoder = transformer.named_steps['onehot']
                    if hasattr(onehot_encoder, 'categories_'):
                        diagnosis['categorical_columns'] = columns
                        diagnosis['categories_per_column'] = {}
                        for i, col in enumerate(columns):
                            diagnosis['categories_per_column'][col] = list(onehot_encoder.categories_[i])
                
                elif name == 'num':
                    diagnosis['numerical_columns'] = columns
        
        diagnosis['success'] = True
        
    except Exception as e:
        diagnosis['success'] = False
        diagnosis['error'] = str(e)
    
    return diagnosis

def preprocess_data(df, model_diagnosis=None):
    """Aplica pr√©-processamento nos dados baseado no diagn√≥stico do modelo"""
    df_processed = df.copy()
    
    # Limpeza b√°sica
    if 'id_cliente' in df_processed.columns:
        df_processed.drop(columns=['id_cliente'], inplace=True)
    
    # Converter datas se existir
    if 'data_ref' in df_processed.columns:
        try:
            df_processed['data_ref'] = pd.to_datetime(df_processed['data_ref'])
        except:
            st.warning("N√£o foi poss√≠vel converter a coluna 'data_ref'")
    
    # Padronizar colunas boolean
    for col in ['posse_de_veiculo', 'posse_de_imovel']:
        if col in df_processed.columns:
            df_processed[col] = df_processed[col].replace({
                'False': 'N', 'True': 'S', False: 'N', True: 'S'
            })
    
    # Padronizar educa√ß√£o
    mapeamento_educacao = {
        'Secund√°rio': 'M√©dio',
        'Prim√°rio': 'Fundamental',
    }
    if 'educacao' in df_processed.columns:
        df_processed['educacao'] = df_processed['educacao'].replace(mapeamento_educacao)
    
    # Processar com base no diagn√≥stico do modelo
    if model_diagnosis and model_diagnosis.get('success'):
        categories_expected = model_diagnosis.get('categories_per_column', {})
        
        for col, expected_categories in categories_expected.items():
            if col in df_processed.columns:
                if any(val in expected_categories for val in [True, False]):
                    # Modelo espera booleanos
                    mapping = {
                        'Y': True, 'N': False, 'S': True,
                        'YES': True, 'NO': False, 'SIM': True, 'NAO': False, 'N√ÉO': False,
                        '1': True, '0': False, 1: True, 0: False,
                        'TRUE': True, 'FALSE': False, 'T': True, 'F': False,
                        True: True, False: False
                    }
                    df_processed[col] = df_processed[col].astype(str).str.upper().map(mapping)
                    df_processed[col] = df_processed[col].fillna(False)
                else:
                    # Modelo espera strings
                    df_processed[col] = df_processed[col].astype(str)
                    df_processed[col] = df_processed[col].replace(['nan', 'None'], 'missing')
                    df_processed[col] = df_processed[col].fillna('missing')
    
    # Processar colunas num√©ricas
    colunas_numericas = ['qtd_filhos', 'idade', 'tempo_emprego', 'qt_pessoas_residencia', 'renda']
    for col in colunas_numericas:
        if col in df_processed.columns:
            df_processed[col] = pd.to_numeric(df_processed[col], errors='coerce')
            df_processed[col] = df_processed[col].fillna(0)
    
    # Determinar colunas dispon√≠veis
    if model_diagnosis and 'categorical_columns' in model_diagnosis:
        colunas_categoricas = model_diagnosis['categorical_columns']
        colunas_numericas = model_diagnosis['numerical_columns']
    else:
        colunas_categoricas = ['sexo', 'posse_de_veiculo', 'posse_de_imovel', 
                              'tipo_renda', 'educacao', 'estado_civil', 'tipo_residencia']
        colunas_numericas = ['qtd_filhos', 'idade', 'tempo_emprego', 
                            'qt_pessoas_residencia', 'renda']
    
    colunas_existentes = list(colunas_categoricas) + list(colunas_numericas)
    colunas_disponiveis = [col for col in colunas_existentes if col in df_processed.columns]
    
    return df_processed, colunas_disponiveis

def generate_score_report(df_original, predictions, probabilities):
    """Gera relat√≥rio de escoragem"""
    df_resultado = df_original.copy()
    df_resultado['score_probabilidade'] = probabilities
    df_resultado['score_classe'] = predictions
    df_resultado['score_rating'] = pd.cut(
        probabilities,
        bins=[0, 0.1, 0.3, 0.5, 0.7, 1.0],
        labels=['Excelente', 'Bom', 'Regular', 'Ruim', 'P√©ssimo']
    )
    
    return df_resultado

# ============================================================================
# TELAS DA APLICA√á√ÉO
# ============================================================================

def tela_carregamento():
    """Tela para carregar modelo e dados"""
    st.title("üìÅ Carregamento de Dados e Modelo")
    st.markdown("---")
    
    col1, col2 = st.columns(2)
    
    # Carregamento do Modelo
    with col1:
        st.header("ü§ñ Carregamento do Modelo")
        
        model_file = st.text_input("Nome do arquivo do modelo:", value="model_final.pkl")
        
        if st.button("üîÑ Carregar Modelo", type="primary"):
            with st.spinner("Carregando modelo..."):
                model_result, model_success = load_model(model_file)
                
                if model_success:
                    st.session_state.model = model_result
                    st.success("‚úÖ Modelo carregado com sucesso!")
                    
                    # Diagnosticar o modelo
                    diagnosis = diagnose_model(model_result)
                    st.session_state.model_diagnosis = diagnosis
                    
                    if diagnosis['success']:
                        st.info("üîç Diagn√≥stico do modelo realizado!")
                        st.balloons()
                    else:
                        st.warning(f"‚ö†Ô∏è Diagn√≥stico falhou: {diagnosis.get('error', 'Erro desconhecido')}")
                else:
                    st.error(f"‚ùå Erro ao carregar modelo: {model_result}")
    
    # Carregamento dos Dados
    with col2:
        st.header("üìä Carregamento dos Dados")
        
        uploaded_file = st.file_uploader(
            "Selecione o arquivo CSV:",
            type=['csv'],
            help="Fa√ßa upload de um arquivo CSV com os dados para escoragem"
        )
        
        if uploaded_file is not None:
            try:
                df = pd.read_csv(uploaded_file)
                st.session_state.df_original = df
                st.success(f"‚úÖ Arquivo carregado: {len(df)} registros")
                
                # M√©tricas
                col_info1, col_info2, col_info3 = st.columns(3)
                with col_info1:
                    st.metric("Registros", len(df))
                with col_info2:
                    st.metric("Colunas", len(df.columns))
                with col_info3:
                    st.metric("Valores Nulos", df.isnull().sum().sum())
                
                # Pr√©via
                with st.expander("üëÄ Pr√©via dos Dados"):
                    st.dataframe(df.head(10))
                
            except Exception as e:
                st.error(f"‚ùå Erro ao carregar arquivo: {str(e)}")
    
    # Status Geral
    st.markdown("---")
    st.header("üìã Status Geral")
    
    col_status1, col_status2 = st.columns(2)
    
    with col_status1:
        if 'model' in st.session_state:
            st.success("ü§ñ Modelo: Carregado")
        else:
            st.error("ü§ñ Modelo: N√£o carregado")
    
    with col_status2:
        if 'df_original' in st.session_state:
            st.success("üìä Dados: Carregados")
        else:
            st.error("üìä Dados: N√£o carregados")
    
    if 'model' in st.session_state and 'df_original' in st.session_state:
        st.success("üéâ Tudo pronto! V√° para a aba 'Diagn√≥stico' para continuar.")

def tela_diagnostico():
    """Tela para diagn√≥stico e valida√ß√£o dos dados"""
    st.title("üîç Diagn√≥stico e Valida√ß√£o")
    st.markdown("---")
    
    if 'df_original' not in st.session_state:
        st.error("‚ùå Dados n√£o carregados. V√° para a aba 'Carregamento' primeiro.")
        return
    
    df = st.session_state.df_original
    
    col1, col2 = st.columns(2)
    
    # An√°lise dos Dados
    with col1:
        st.header("üìä An√°lise dos Dados")
        
        # Informa√ß√µes gerais
        col_info1, col_info2, col_info3 = st.columns(3)
        with col_info1:
            st.metric("Registros", len(df))
        with col_info2:
            st.metric("Colunas", len(df.columns))
        with col_info3:
            st.metric("Valores Nulos", df.isnull().sum().sum())
        
        # Colunas dispon√≠veis
        st.subheader("üìã Colunas Dispon√≠veis")
        for col in df.columns:
            st.write(f"‚Ä¢ {col} ({df[col].dtype})")
    
    # Diagn√≥stico do Modelo
    with col2:
        st.header("ü§ñ Diagn√≥stico do Modelo")
        
        if 'model_diagnosis' in st.session_state and st.session_state.model_diagnosis['success']:
            diagnosis = st.session_state.model_diagnosis
            
            st.subheader("üìã Colunas Categ√≥ricas")
            if 'categorical_columns' in diagnosis:
                for col in diagnosis['categorical_columns']:
                    st.write(f"‚Ä¢ {col}")
            
            st.subheader("üî¢ Colunas Num√©ricas")
            if 'numerical_columns' in diagnosis:
                for col in diagnosis['numerical_columns']:
                    st.write(f"‚Ä¢ {col}")
        else:
            st.error("‚ùå Diagn√≥stico do modelo n√£o dispon√≠vel")
    
    st.markdown("---")
    st.dataframe(df.head())
    
    # An√°lise de Valores √önicos
    st.subheader("üîç An√°lise de Categorias")
    categorical_cols = df.select_dtypes(include=['object']).columns
    
    for col in categorical_cols:
        with st.expander(f"üìù {col}"):
            unique_vals = df[col].unique()
            st.write(f"**Valores √∫nicos ({len(unique_vals)}):** {list(unique_vals)}")
            
            if len(unique_vals) > 20:
                st.warning("‚ö†Ô∏è Muitas categorias √∫nicas - pode precisar de agrupamento")

def tela_escoragem():
    """Tela principal de escoragem"""
    st.title("üöÄ Escoragem e Resultados")
    st.markdown("---")
    
    # Verifica√ß√µes iniciais
    if 'model' not in st.session_state:
        st.error("‚ùå Modelo n√£o carregado. V√° para a aba 'Carregamento' primeiro.")
        return
    
    if 'df_original' not in st.session_state:
        st.error("‚ùå Dados n√£o carregados. V√° para a aba 'Carregamento' primeiro.")
        return
    
    # Execu√ß√£o da Escoragem
    st.header("‚ö° Executar Escoragem")
    
    col_exec1, col_exec2 = st.columns([2, 1])
    
    with col_exec1:
        if st.button("üöÄ Executar Escoragem", type="primary", use_container_width=True):
            with st.spinner("Executando escoragem..."):
                try:
                    start_time = time.time()
                    
                    df = st.session_state.df_original
                    model_diagnosis = st.session_state.get('model_diagnosis', None)
                    
                    # Pr√©-processamento
                    df_processed, colunas_disponiveis = preprocess_data(df, model_diagnosis)
                    
                    # Preparar dados para o modelo
                    X_score = df_processed[colunas_disponiveis]
                    
                    # Fazer predi√ß√µes
                    predictions = st.session_state.model.predict(X_score)
                    probabilities = st.session_state.model.predict_proba(X_score)[:, 1]
                    
                    end_time = time.time()
                    
                    # Gerar relat√≥rio
                    df_resultado = generate_score_report(df, predictions, probabilities)
                    
                    # Armazenar resultados
                    st.session_state.df_resultado = df_resultado
                    st.session_state.processing_time = end_time - start_time
                    
                    st.success(f"‚úÖ Escoragem conclu√≠da em {end_time - start_time:.2f} segundos!")
                    st.balloons()
                    
                except Exception as e:
                    st.error(f"‚ùå Erro durante a escoragem: {str(e)}")
                    st.error("üõ†Ô∏è Verifique se os dados est√£o no formato correto")
    
    with col_exec2:
        if 'df_resultado' in st.session_state:
            st.success("‚úÖ Escoragem Conclu√≠da")
            st.metric("Tempo", f"{st.session_state.processing_time:.2f}s")
        else:
            st.info("‚è≥ Aguardando execu√ß√£o")
    
    # Resultados
    if 'df_resultado' in st.session_state:
        mostrar_resultados()

def mostrar_resultados():
    """Mostra os resultados da escoragem"""
    st.markdown("---")
    st.header("üìä Resumo dos Resultados")
    
    df_res = st.session_state.df_resultado
    
    # M√©tricas principais
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        avg_prob = df_res['score_probabilidade'].mean()
        st.metric("Probabilidade M√©dia", f"{avg_prob:.1%}")
    
    with col2:
        high_risk = (df_res['score_probabilidade'] > 0.5).sum()
        st.metric("Alto Risco", f"{high_risk} ({high_risk/len(df_res):.1%})")
    
    with col3:
        low_risk = (df_res['score_probabilidade'] <= 0.5).sum()
        st.metric("Baixo Risco", f"{low_risk} ({low_risk/len(df_res):.1%})")
    
    with col4:
        st.metric("Total", len(df_res))
    
    # Gr√°ficos
    col_chart1, col_chart2 = st.columns(2)
    
    with col_chart1:
        st.subheader("üìà Distribui√ß√£o de Probabilidades")
        fig_hist = px.histogram(
            df_res, 
            x='score_probabilidade',
            nbins=20,
            title="Distribui√ß√£o de Probabilidades"
        )
        st.plotly_chart(fig_hist, use_container_width=True)
    
    with col_chart2:
        st.subheader("üéØ Distribui√ß√£o por Rating")
        rating_counts = df_res['score_rating'].value_counts()
        fig_bar = px.bar(
            x=rating_counts.index,
            y=rating_counts.values,
            title="Quantidade por Rating"
        )
        st.plotly_chart(fig_bar, use_container_width=True)
    
    # Tabela de resultados
    st.markdown("---")
    st.header("üìã Resultados Detalhados")
    
    # Filtros
    col_filter1, col_filter2 = st.columns(2)
    
    with col_filter1:
        rating_filter = st.multiselect(
            "Filtrar por Rating:",
            options=df_res['score_rating'].unique(),
            default=df_res['score_rating'].unique()
        )
    
    with col_filter2:
        prob_range = st.slider(
            "Filtrar por Probabilidade:",
            min_value=0.0,
            max_value=1.0,
            value=(0.0, 1.0),
            step=0.01
        )
    
    # Aplicar filtros
    df_filtered = df_res[
        (df_res['score_rating'].isin(rating_filter)) &
        (df_res['score_probabilidade'] >= prob_range[0]) &
        (df_res['score_probabilidade'] <= prob_range[1])
    ]
    
    st.dataframe(df_filtered, use_container_width=True, height=400)
    st.caption(f"Mostrando {len(df_filtered)} de {len(df_res)} registros")
    
    # Download
    st.markdown("---")
    st.header("üíæ Download dos Resultados")
    
    csv_buffer = io.StringIO()
    df_res.to_csv(csv_buffer, index=False)
    csv_data = csv_buffer.getvalue()
    
    st.download_button(
        label="üì• Baixar Resultados (CSV)",
        data=csv_data,
        file_name=f"escoragem_{datetime.now().strftime('%Y%m%d_%H%M%S')}.csv",
        mime="text/csv",
        use_container_width=True
    )

# ============================================================================
# SIDEBAR E NAVEGA√á√ÉO
# ============================================================================

def criar_sidebar():
    """Cria a barra lateral com navega√ß√£o e status"""
    st.sidebar.title("üß≠ Navega√ß√£o")
    st.sidebar.markdown("---")
    
    # Sele√ß√£o da tela
    tela_selecionada = st.sidebar.radio(
        "Selecione a tela:",
        ["üìÅ Carregamento", "üîç Diagn√≥stico", "üöÄ Escoragem"],
        index=0
    )
    
    # Status
    st.sidebar.markdown("---")
    st.sidebar.subheader("üìä Status")
    
    if 'model' in st.session_state:
        st.sidebar.success("ü§ñ Modelo: Carregado")
    else:
        st.sidebar.error("ü§ñ Modelo: N√£o carregado")
    
    if 'df_original' in st.session_state:
        st.sidebar.success("üìä Dados: Carregados")
        st.sidebar.info(f"üìà {len(st.session_state.df_original)} registros")
    else:
        st.sidebar.error("üìä Dados: N√£o carregados")
    
    if 'df_resultado' in st.session_state:
        st.sidebar.success("‚úÖ Escoragem: Conclu√≠da")
    else:
        st.sidebar.warning("‚è≥ Escoragem: Pendente")
    
    st.sidebar.markdown("---")
    
    # Bot√£o limpar cache
    if st.sidebar.button("üóëÔ∏è Limpar Cache", use_container_width=True):
        st.cache_data.clear()
        for key in list(st.session_state.keys()):
            del st.session_state[key]
        st.sidebar.success("Cache limpo!")
        st.rerun()
    
    return tela_selecionada

# ============================================================================
# FUN√á√ÉO PRINCIPAL
# ============================================================================

def main():
    """Fun√ß√£o principal da aplica√ß√£o"""
    
    # Criar sidebar e obter tela selecionada
    tela_selecionada = criar_sidebar()
    
    # Roteamento das telas
    if tela_selecionada == "üìÅ Carregamento":
        tela_carregamento()
    elif tela_selecionada == "üîç Diagn√≥stico":
        tela_diagnostico()
    elif tela_selecionada == "üöÄ Escoragem":
        tela_escoragem()

if __name__ == "__main__":
    main()